File `main.cpp`:

```C++
#include <stdio.h>
#include <Windows.h>
#include <string.h>
#include <time.h>

#define MIN(a, b) ((a) < (b) ? (a) : (b))
#define err(fmt, ...) fprintf(stderr, fmt, __VA_ARGS__)

#define FREAD_BLOCK_SIZE  (2048)
#define FWRITE_BLOCK_SIZE (2048)
#define ENC_BLOCK_SIZE (2)
#define ENC_NUM_ROUND (64)
#define KEY_SIZE (4)

const char* getExtension(const char* szPath);
void enumFilesAndFolders(const char* szPath, void(*encryptFunc)(const char*, unsigned int));
void encrypt1(unsigned int nRound, unsigned char v[ENC_BLOCK_SIZE], unsigned char key[KEY_SIZE]);
void encrypt2(unsigned char* data, unsigned int dataLength, unsigned char* key, unsigned int keyLength);
void encrypt(const char* szPath, unsigned int fileSize);
void initKey();

static unsigned char g_key1[KEY_SIZE];
static unsigned int g_key2;

int main(int argc, char* argv[])
{
	initKey();
	enumFilesAndFolders("C:\\Users\\xikhud\\Desktop\\EncFolder", encrypt);
	return 0;
}

const char* getExtension(const char* szPath)
{
	int i = strlen(szPath) - 1;
	while (i >= 0 && szPath[i] != '.')
		--i;
	if (i < 0)
		return NULL;
	return (szPath + i + 1);
}

void enumFilesAndFolders(const char* szPath, void(*encryptFunc)(const char*, unsigned int))
{
	if (strlen(szPath) > 250)
		return;
	char szTmpPath[260];
	strcpy(szTmpPath, szPath);
	strcat(szTmpPath, "\\*"); // strlen(szPath) + strlen("\\*") must < MAX_PATH (which is 260)

	WIN32_FIND_DATA file;
	HANDLE hFind = FindFirstFileA(szTmpPath, &file);
	if (hFind == INVALID_HANDLE_VALUE)
	{
		err("[+] Invalid handle\n");
		return;
	}
	do
	{
		const char* szFileName = file.cFileName;
		if (file.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) // if this is folder, then we continue. We only encrypt files, not folders
			continue;										  // but we can actually recursive call this function with this folder's name as the first param, to encrypt all data in it, too
		strcpy(szTmpPath, szPath);
		strcat(szTmpPath, "\\");
		strcat(szTmpPath, szFileName);
		unsigned int fileSize = (unsigned int)file.nFileSizeLow;
		encryptFunc(szTmpPath, fileSize);
	} while (FindNextFileA(hFind, &file));
	FindClose(hFind);
}

void encrypt1(unsigned int nRound, unsigned char v[ENC_BLOCK_SIZE], unsigned char key[KEY_SIZE])
{
	unsigned char v0 = v[0], v1 = v[1];
	unsigned int sum = 0, delta = 0x9E3779B9;
	for (unsigned int i = 0; i < nRound; ++i)
	{
		v0 += (((v1 << 4) ^ (v1 >> 5)) + v1) ^ (sum + key[sum % KEY_SIZE]);
		sum += delta;
		v1 += (((v0 << 4) ^ (v0 >> 5)) + v0) ^ (sum + key[(sum >> 11) % KEY_SIZE]);
	}
	v[0] = v0; v[1] = v1;
}

void encrypt2(unsigned char * data, unsigned int dataLength, unsigned char * key, unsigned int keyLength)
{
	for (unsigned int i = 0; i < dataLength; ++i)
	{
		data[i] = data[i] ^ key[i % keyLength];
	}
}

void encrypt(const char* szPath, unsigned int fileSize)
{
	const char* szSpecialTypes[3] = { "exe", "png", "pdf" };
	const char* szExt = getExtension(szPath);
	if (strcmp(szExt, "enc") == 0) // if this file is already encrypted, return
		return;
	bool bIsSpecial = false;
	for (int i = 0; i < sizeof(szSpecialTypes) / sizeof(szSpecialTypes[0]); ++i)
		if (strcmp(szExt, szSpecialTypes[i]) == 0)
			bIsSpecial = true;
	FILE* f = fopen(szPath, "rb");
	if (f == NULL)
	{
		err("[+] Cannot open file %s\n", szPath);
		return;
	}
	unsigned char* lpBuffer = (unsigned char*)malloc(fileSize);
	if (lpBuffer == NULL)
	{
		err("[+] Not enough memory\n");
		fclose(f);
		return;
	}
	unsigned int nRead = 0;
	while (nRead < fileSize)
	{
		int n = fread((void*)(lpBuffer + nRead), sizeof(unsigned char), MIN(FREAD_BLOCK_SIZE, fileSize - nRead), f);
		nRead += n;
	}
	fclose(f);
	if (bIsSpecial)
	{
		unsigned int nBlock = fileSize / ENC_BLOCK_SIZE;
		for (unsigned int i = 0; i < nBlock; ++i)
		{
			encrypt1(ENC_NUM_ROUND, &lpBuffer[2 * i], g_key1);
		}
	}
	else
	{
		encrypt2(lpBuffer, fileSize, (unsigned char*)&g_key2, KEY_SIZE);
	}

	char szNewPath[260];
	strcpy(szNewPath, szPath);
	strcat(szNewPath, ".enc");
	FILE* newFile = fopen(szNewPath, "wb");
	unsigned int nWrite = 0;
	if (newFile == NULL)
	{
		free(lpBuffer);
		return;
	}
	while (nWrite < fileSize)
	{
		int n = fwrite((const void*)(lpBuffer + nWrite), sizeof(unsigned char), MIN(FWRITE_BLOCK_SIZE, fileSize - nWrite), newFile);
		nWrite += n;
	}
	fclose(newFile);
	DeleteFileA(szPath);
	free(lpBuffer);
}

void initKey()
{
	srand(time(0));
	for (int i = 0; i < KEY_SIZE; ++i)
		g_key1[i] = (unsigned int)rand() % 256;
	g_key2 = (0xDE << 24) | (0xAD << 16) | (0xC0 << 8) | (0xDE);
}
```

Đoạn chương trình này sẽ tìm kiểm file nằm trong thư mục `C:\Users\xikhud\Desktop\EncFolder` để mã hoá. Nó sử dụng đuôi file để xác định xem file xem nào là file đặc biệt (đuôi file có dạng `"exe", "png", "pdf"`). Từ đó, file đặc biệt sẽ bị mã hoá bằng hàm `encrypt1` còn file khác mã hoá bằng hàm `encrypt2`.

Hàm `encrypt2` chỉ đơn giản là xor file content với key "\xDE\xC0\xAD\xDE", vì thế có thể decrypt các file không phải `exe`, `png` hay `pdf` để xem có hint gì không đã. File `flag.txt.enc` có vẻ khả nghi, nhưng sau khi decrypt chỉ nhận được hint như sau:
```
Flag is not here.
But, keep going.

Since you're here, I will give you a gift: the first 3 least significant bits of key is 110.
What you gonna do ?

Good luck.
```
Hint cho biết rằng 3 bit cuối của key là `110`. OK, let's continue.

Search chuỗi `delta = 0x9E3779B9` trên github, có thể nhận ra rằng hàm encrypt1 bản chất là hàm `xtea_encrypt` với số round mã hoá là `64` (tham khảo https://github.com/cromulencellc/hackasat-final-2020/blob/master/flatsat_openmsp430/software/client/radio/xtea_encrypt.c). 

```C
void xtea_encrypt(volatile uint32_t v[2], const uint32_t k[4])
{
    volatile uint32_t y=v[0],z=v[1];
	uint32_t sum=0,delta=0x9E3779B9;
    uint16_t n=16;

    while(n-->0)
    {
            y += (z << 4 ^ z >> 5) + z ^ sum + k[sum&3];
            sum += delta;
            z += (y << 4 ^ y >> 5) + y ^ sum + k[sum>>11 & 3];
    }

    v[0]=y; v[1]=z;
}

void xtea_decrypt(volatile uint32_t v[2], const uint32_t k[4])
{
    volatile uint32_t y=v[0],z=v[1];
	uint32_t sum=0xE3779B90, delta=0x9E3779B9;         
    uint16_t n=16;

    /* sum = delta<<5, in general sum = delta * n */
    while(n-->0)
    {
            z -= (y << 4 ^ y >> 5) + y ^ sum + k[sum>>11 & 3];
            sum -= delta;
            y -= (z << 4 ^ z >> 5) + z ^ sum + k[sum&3];
    }

	v[0]=y; v[1]=z;
}
```

Đây là đoạn code `xtea_encrypt` và `xtea_decrypt` với số round là 16, để ý ở hàm `decrypt` sum có giá trị `0xE3779B90` chính là bằng `delta * round = 0x9E3779B9 * 16`. Chỉ cần chỉnh lại số round thành 64 và `sum = 0x278dde6e40` là có thể áp dụng để giải mã file cho bài này.

Ban đầu tôi nghĩ rằng BTC sẽ ra đề theo kiểu dò `seed` của hàm `rand()` theo timestamp vì có thể biết thời gian tạo file `flag.png.enc` là `10:37 21/04/2021`. Nhưng dò tới dò lui đều không tìm được key đúng nên tôi quyết định dò 4 byte của key bằng đoạn chương trình sau:

```C++
#include <stdio.h>
#include <Windows.h>
#include <string.h>
#include <time.h>
#include <stdint.h>

#define MIN(a, b) ((a) < (b) ? (a) : (b))
#define err(fmt, ...) fprintf(stderr, fmt, __VA_ARGS__)

#define FREAD_BLOCK_SIZE  (2048)
#define FWRITE_BLOCK_SIZE (2048)
#define ENC_BLOCK_SIZE (2)
#define ENC_NUM_ROUND (64)
#define KEY_SIZE (4)


static unsigned char g_key1[KEY_SIZE];
static unsigned int g_key2;

void xtea_encrypt(int n, unsigned char v[2], unsigned char k[4])
{
	unsigned char y = v[0], z = v[1];
	unsigned int sum = 0, delta = 0x9E3779B9;

	while (n-- > 0)
	{
		y += (z << 4 ^ z >> 5) + z ^ sum + k[sum & 3];
		sum += delta;
		z += (y << 4 ^ y >> 5) + y ^ sum + k[sum >> 11 & 3];
	}

	v[0] = y; v[1] = z;
}

void xtea_decrypt(int n, unsigned char v[2], const unsigned char k[4])
{
	unsigned char y = v[0], z = v[1];
	unsigned int sum = 0x278dde6e40, delta = 0x9E3779B9;

	/* sum = delta<<5, in general sum = delta * n */
	while (n-- > 0)
	{
		z -= (y << 4 ^ y >> 5) + y ^ sum + k[sum >> 11 & 3];
		sum -= delta;
		y -= (z << 4 ^ z >> 5) + z ^ sum + k[sum & 3];
	}

	v[0] = y; v[1] = z;
}

int decrypt() {
	unsigned int fileSize = 64;
	char szPath[] = "C:\\Users\\Admin\\Desktop\\EncFolder\\flag.png.enc";
	WIN32_FIND_DATAA file;
	HANDLE hFind = FindFirstFileA(szPath, &file);
	if (hFind == INVALID_HANDLE_VALUE)
	{
		printf("File not found (%d)\n", GetLastError());
		return 0;
	}
	else
	{
		fileSize = file.nFileSizeLow;
		FindClose(hFind);
	}
	printf("File size: %d\n", fileSize);
	FILE* f = fopen(szPath, "rb");
	if (f == NULL)
	{
		err("[+] Cannot open file %s\n", szPath);
		return 0;
	}
	unsigned char* lpBuffer = (unsigned char*)malloc(fileSize);
	if (lpBuffer == NULL)
	{
		err("[+] Not enough memory\n");
		fclose(f);
		return 0;
	}
	unsigned int nRead = 0;
	while (nRead < fileSize)
	{
		int n = fread((void*)(lpBuffer + nRead), sizeof(unsigned char), MIN(FREAD_BLOCK_SIZE, fileSize - nRead), f);
		nRead += n;
	}
	fclose(f);
	unsigned int nBlock = 8 / ENC_BLOCK_SIZE;
	

	unsigned char tmp[8];
	for (char a = 0; a < 256; a++)
	{
		g_key1[0] = a;
		for (char b = 0; b < 256; b++)
		{
			g_key1[1] = b;
			for (char c = 0; c < 256; c++)
			{
				g_key1[2] = c;
				for (char d = 0; d < 256; d++)
				{
					g_key1[3] = d;
					memcpy(tmp, lpBuffer, 8);
					for (int i = nBlock - 1; i >= 0; i--)
					{
						xtea_decrypt(ENC_NUM_ROUND, &tmp[2 * i], g_key1);
						if (tmp[0] == 0x89 && tmp[1] == 'P' && tmp[2] == 'N' && tmp[3] == 'G') {
							printf("found: %d %d %d %d\n", a, b, c, d);
							nBlock = fileSize / ENC_BLOCK_SIZE;
							for (int i = nBlock - 1; i >= 0; i--)
							{
								xtea_decrypt(ENC_NUM_ROUND, &lpBuffer[2 * i], g_key1);
							}
							FILE* newFile = fopen("C:\\Users\\Admin\\Desktop\\EncFolder\\flag.png", "wb");
							unsigned int nWrite = 0;
							if (newFile == NULL)
							{
								free(lpBuffer);
								return 0;
							}
							while (nWrite < fileSize)
							{
								int n = fwrite((const void*)(lpBuffer + nWrite), sizeof(unsigned char), MIN(FWRITE_BLOCK_SIZE, fileSize - nWrite), newFile);
								nWrite += n;
							}
							fclose(newFile);
							return 1;
						}
					}
				}
			}
		}
	}

	return 0;
}

int main(int argc, char* argv[])
{
	decrypt();
	return 0;
}
```

Thật may khi vừa chạy thì dính ngay key là `0, 0, 0, 0`, file flag.png sau khi decrypt được có chứa flag.

![flag](https://user-images.githubusercontent.com/17811861/119600469-4b2e9e80-be11-11eb-8620-cbe7c98d060d.png)